# Linked List Cycle

[é¡Œç›®é€£çµ](https://leetcode.com/problems/linked-list-cycle/)

## é¡Œç›®æè¿°
åŸæ–‡ï¼š

Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that** `pos` **is not passed as a parameter.**

Return `true` *if there is a cycle in the linked list*. Otherwise, return `false`.

 

----

GPT 4 ç¿»è­¯ï¼š

çµ¦å®š `head`ï¼Œå³éˆè¡¨çš„é ­ç¯€é»ï¼Œåˆ¤æ–·éˆè¡¨ä¸­æ˜¯å¦æœ‰å¾ªç’°ã€‚

å¦‚æœéˆè¡¨ä¸­å­˜åœ¨æŸå€‹ç¯€é»ï¼Œé€šéä¸æ–·è·Ÿéš¨ `next` æŒ‡é‡å¯ä»¥å†æ¬¡åˆ°é”è©²ç¯€é»ï¼Œå‰‡è©²éˆè¡¨å­˜åœ¨å¾ªç’°ã€‚åœ¨å…§éƒ¨ï¼Œ`pos` è¢«ç”¨ä¾†è¡¨ç¤ºå°¾ç¯€é»çš„ `next` æŒ‡é‡æ‰€é€£æ¥çš„ç¯€é»çš„ç´¢å¼•ã€‚**æ³¨æ„ï¼Œ**`pos` **ä¸ä½œç‚ºåƒæ•¸å‚³éã€‚**

å¦‚æœéˆè¡¨ä¸­å­˜åœ¨å¾ªç’°ï¼Œå‰‡è¿”å› `true`ã€‚å¦å‰‡ï¼Œè¿”å› `false`ã€‚

----

Example 1

![Example 1](example1.png)

```
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```

Example 2

![Example 2](example2.png)

```
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```

Example 3

![Example 3](example3.png)

```
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```

Constraints:

* The number of the nodes in the list is in the range `[0, 10^4]`.
* `-10^5 <= Node.val <= 10^5`
* `pos` is `-1` or a **valid index** in the linked-list.

## æ€è·¯

ä»¥äººé¡çš„æ€è€ƒæ–¹å¼ï¼šå¦‚ä½•åˆ¤æ–·é‡è¤‡ï¼Ÿé‚£å°±æŠŠæœ‰èµ°éçš„ç´€éŒ„èµ·ä¾†ï¼Œç„¶å¾Œæ¯æ‰éƒ½å»åˆ¤æ–·é€™å€‹ç¯€é»æ˜¯ä¸æ˜¯èµ°éäº†ã€‚é€™æ¨£åšå¯ä»¥å—ï¼Ÿå¯ä»¥ï¼  

ä½†å•é¡Œä¾†äº†ï¼Œåˆ¤æ–·éå»æœ‰æ²’æœ‰å­˜åœ¨éï¼Œæ„Ÿè¦ºå¯ä»¥ç”¨ Set ä¾†ç•¶æˆ‘å€‘çš„è¨˜æ†¶å€ï¼Œä½†æ˜¯ Set èƒ½å¤ æ”¾ä¸€å€‹ ListNode é€²å»å—ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥ï¼  

å¯ä»¥æ”¾ä¸å¯è®Šï¼ˆimmutableï¼‰çš„è³‡æ–™é¡å‹  
1. æ•¸å­—é¡å‹ï¼šä¾‹å¦‚æ•´æ•¸ï¼ˆintï¼‰ã€æµ®é»æ•¸ï¼ˆfloatï¼‰å’Œè¤‡æ•¸ï¼ˆcomplexï¼‰ã€‚
2. å­—ç¬¦ä¸²ï¼ˆstringï¼‰ã€‚
3. å…ƒçµ„ï¼ˆtupleï¼‰ï¼Œä½†å‰ææ˜¯å…ƒçµ„åŒ…å«çš„å…ƒç´ ä¹Ÿå¿…é ˆæ˜¯ä¸å¯è®Šçš„ã€‚  

ä¸å¯ä»¥æ”¾å…¥å¯è®Šï¼ˆmutableï¼‰çš„è³‡æ–™é¡å‹
1. åˆ—è¡¨ï¼ˆlistï¼‰ã€‚
2. å­—å…¸ï¼ˆdictï¼‰ã€‚
3. é›†åˆï¼ˆsetï¼‰æœ¬èº«ä¹Ÿæ˜¯å¯è®Šçš„ï¼Œå› æ­¤ä¸èƒ½åŒ…å«åœ¨å¦ä¸€å€‹é›†åˆä¸­ã€‚

é‚£ class å¯ä¸å¯ä»¥å‘¢ï¼Ÿæ˜¯å¯ä»¥çš„ï¼Œå› ç‚º class åœ¨å‰µå»ºå¯¦ä¾‹æ™‚ï¼Œæœƒåˆ©ç”¨å…¶è¨˜æ†¶é«”ä½ç½®åš hashï¼Œæœƒæ˜¯ç¨ä¸€ç„¡äºŒçš„å€¼ã€‚  

---

**æ–¹æ³• A: Iterative + Set**

* æ­¥é©Ÿ
    1. éæ­·æ‰€æœ‰ç¯€é»ï¼Œå°‡éæ­·çš„ç¯€é»æ”¾å…¥ Set ä¸­ã€‚
    2. å¦‚æœéæ­·çš„ç¯€é»å­˜åœ¨æ–¼ Set ä¸­ï¼Œé‚£å°±ä»£è¡¨æœ‰ Cycleã€‚

* è¤‡é›œåº¦
    * æ™‚é–“è¤‡é›œåº¦: O(N)
    * ç©ºé–“è¤‡é›œåº¦: O(N)

---

æ™‚é–“è¤‡é›œåº¦æ‡‰è©²æ˜¯æ²’è¾¦æ³•å†è®Šæ›´ä½äº†ï¼Œå› ç‚ºä¸€å®šè¦éæ­·ä¸€éï¼Œä½†ç©ºé–“è¤‡é›œåº¦æœ‰æ²’æœ‰è¾¦æ³•å†å¾€ä¸‹é™ï¼Ÿä¹Ÿå°±æ˜¯ä¸ç”¨ä»»ä½•ä¸€å€‹è¨˜æ†¶å€ï¼Œå°±èƒ½åšå®Œã€‚æˆ‘å€‘å¯ä»¥å˜—è©¦çœ‹çœ‹ï¼š  

ä½ çŸ¥é“çš„æœ‰å“ªäº›æ¼”ç®—æ³•ï¼Œå¯ä»¥ä¸ç”¨è€—è²»ä»»ä½•ç©ºé–“è¤‡é›œåº¦åšåˆ°å‘¢ï¼Ÿ  
å¯èƒ½å¯ä»¥çš„ï¼š  
âœ… BFS/DFS  
âœ… Binary Search  
âœ… Two Pointer  
âœ… Sliding Window  

ä¸€å®šä¸è¡Œçš„ï¼š  
âŒ Dynamic Programming  
âŒ Hashing  

æ ¹æœ¬é¡Œç„¡é—œçš„ï¼š  
âŒ Bit manipulation: è·Ÿæ•¸å­—ç„¡é—œã€‚  
âŒ Greedy Approach: ä¸¦éæ‰¾æœ€å„ªè§£æˆ–è·¯å¾‘ã€‚  
âŒ Divide and Conquer: ç„¡æ³•æ‹†åˆ†ï¼Œä¸”å•é¡Œéç¨ç«‹ã€‚  

---

æ¯ä¸€å€‹éƒ½ä¾†è©¦è©¦çœ‹ï¼š  
âŒ BFS/DFS: åªæœ‰ä¸€æ¢è·¯å¾‘ï¼Œå°±æ˜¯å–®ç´”ç”¨ Loop åš Traversalï¼Œæˆ‘å€‘æ–¹æ³• A å˜—è©¦éäº†ã€‚è¦åˆ¤æ–·é‡è¤‡éœ€è¦æœ‰è¨˜æ†¶å€å”åŠ©ã€‚  
âŒ Binary Search: Linked List è¦å¯¦ä½œ Binary Search è‹¥ä¸ç”¨è¨˜æ†¶å€ï¼Œå¯èƒ½æœƒè®“æ™‚é–“è¤‡é›œåº¦å¤§é‡æå‡ã€‚  
ğŸ’¡ Two Pointer:   
ã€€âŒ å·¦å³å‹ï¼šLinked List çš„ç‰¹æ€§ï¼Œå³æŒ‡æ¨™æ²’è¾¦æ³•å¾€å‰ç§»å‹•ã€‚  
ã€€ğŸ’¡ å¿«æ…¢å‹ï¼šå¿«åœ°æŒ‡æ¨™å¾€å‰è·‘å’Œæ…¢çš„æŒ‡æ¨™å¾€å‰è·‘ï¼Œæœ‰æ²’æœ‰æ©Ÿæœƒæ’åˆ°ï¼Œæ’åˆ°å°±ä»£è¡¨æœ‰ cycle äº†ã€‚  
âŒ Sliding Window: é€šå¸¸æ‡‰ç”¨åœ¨é™£åˆ—ï¼Œä¸é©åˆç”¨åœ¨ Linked List ä¸­ã€‚  

å°±åªå‰©ä¸€ç¨®å¯èƒ½äº†ï¼Œå°±é€™éº¼å‰›å¥½æ˜¯ä»–å—ï¼Ÿå°çš„ï¼è€Œä¸”é€™å€‹æ–¹æ³•å«åšï¼šFloyd's Cycle Finding Algorithmã€‚ä»–æ˜¯æ€éº¼åšçš„å‘¢ï¼Ÿ  
 
åœ¨è…¦ä¸­æƒ³åƒä¸€ä¸‹ï¼Œå¦‚æœä»Šå¤©æœ‰å…©ä½è·‘è€…åœ¨æ“å ´çš„è·‘é“ä¸Šè·‘æ­¥ï¼Œå¦‚æœé€™å€‹è·‘é“æ˜¯ä¸€å€‹ cycleï¼Œé–‹è·‘å¾Œï¼Œé‚£è·‘å¾—å¿«çš„è·‘è€…ä¸€å®šæœƒå’Œæ…¢çš„è·‘è€…åªè¦ä¸æ˜¯ç­‰é€Ÿå‰é€²ï¼Œä¸€å®šæœƒå†ç¢°åˆ°ã€‚  

**æ‰€ä»¥ä¸€å€‹å¿«æŒ‡æ¨™æ¯ä¸€æ¬¡èµ°å…©æ­¥ã€æ…¢æŒ‡æ¨™æ¯æ¬¡èµ°ä¸€æ­¥ï¼Œæœ‰ä¸€å¤©ä»–å€‘æœƒåœç•™åœ¨åŒä¸€å€‹æŒ‡æ¨™ã€‚**


**æ–¹æ³• 2: Two Pointers**

* æ­¥é©Ÿ
    1. åˆå§‹åŒ– slow å’Œ fast æŒ‡æ¨™ã€‚  
    2. åˆ¤æ–· fast æŒ‡æ¨™æ˜¯å¦ç­‰æ–¼ slow ç¯€é»ï¼Œæ˜¯çš„è©±è¿”å› Trueã€‚

* è¤‡é›œåº¦
    * æ™‚é–“è¤‡é›œåº¦: O(N)
    * ç©ºé–“è¤‡é›œåº¦: O(1)

* å»¶ä¼¸è¨è«–
    * æœ‰æ²’æœ‰å¯èƒ½å³ä½¿æœ‰ cycle ä½†æ°¸é ç„¡æ³•åœç•™åœ¨åŒä¸€ç¯€é»ï¼Ÿ
        * ä¸æœƒï¼Œå› ç‚ºå¿«æŒ‡æ¨™èµ°å¶æ•¸æ ¼ã€æ…¢æŒ‡æ¨™èµ°å¥‡æ•¸æ ¼æ‰€ä»¥åœ¨æœ‰é™æ­¥æ•¸å…§ä¸€å®šæœƒæ’åˆ°ã€‚
